<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from Parser.SyntaxTypes.Statement.SimpleStatement.InputStatement import InputStatement
from Parser.SyntaxTypes.Statement.SimpleStatement.PrintStatement import PrintStatement
from core import core
from Tokens.Token import Token
from Symbols.Symbol import Symbol
from Parser.SyntaxNode.SyntaxNode import SyntaxNode
from Tokens.Constants.TokenConstants import TokenTypes
from Parser.SyntaxTypes.Statement.Statement import Statement
from Parser.SyntaxTypes.Expression.BinaryExpression import BinaryExpression
from Parser.SyntaxTypes.Expression.LiteralExpression.NumberExpression import NumberExpression
from Parser.SyntaxTypes.Expression.IdentifierExpression import IdentifierExpression
from Parser.SyntaxTypes.Expression.LiteralExpression.BooleanExpression import BooleanExpression
from Parser.SyntaxTypes.Statement.SimpleStatement.VarAssignSyntax import VarAssignSyntax
from Parser.SyntaxTypes.Expression.LiteralExpression.StringExpression import StringExpression
from Parser.SyntaxTypes.Expression.ParenthesizedExpression import ParenthesizedExpression
from Parser.SyntaxTypes.Statement.SelectionStatement.ElifStatement import ElifStatement
from Parser.SyntaxTypes.Statement.SelectionStatement.ElseStatement import ElseStatement
from Parser.SyntaxTypes.Statement.SelectionStatement.IfStatement import IfStatement
from Parser.SyntaxTypes.Statement.SelectionStatement.WhileStatement import WhileStatement
from Parser.SyntaxTypes.Statement.SimpleStatement.VarDeclareSyntax import VarDeclareSyntax

class SyntaxEvaluator:

    @staticmethod
    def evaluateExpression(node: SyntaxNode):

        # IS LITERAL LEAF
        if isinstance(node, NumberExpression):
            return node.numberLiteralToken.value

        elif isinstance(node, BooleanExpression):
            return node.booleanLiteralToken.value

        elif isinstance(node, StringExpression):
            return node.stringLiteralToken.value

        # IS IDENTIFIER LEAF
        if isinstance(node, IdentifierExpression):
            varSymbol = core.SymbolsTable.findSymbolByKey(node.identifierToken.value)
            return varSymbol.value

        elif isinstance(node, ParenthesizedExpression):
            return SyntaxEvaluator.evaluateExpression(node.expression)

        elif isinstance(node, BinaryExpression):
            leftTerm = SyntaxEvaluator.evaluateExpression(node.leftTerm)
            rightTerm = SyntaxEvaluator.evaluateExpression(node.rightTerm)
            operator: Token = node.operator

            if operator.type == TokenTypes.PLUS:
                return leftTerm + rightTerm
            elif operator.type == TokenTypes.MINUS:
                return leftTerm - rightTerm
            elif operator.type == TokenTypes.DIVISION:
                return leftTerm / rightTerm
            elif operator.type == TokenTypes.MULTIPLY:
                return leftTerm * rightTerm

            elif operator.type == TokenTypes.GREATER:
                return leftTerm &gt; rightTerm
            elif operator.type == TokenTypes.GREATER_EQUALS:
                return leftTerm &gt;= rightTerm
            elif operator.type == TokenTypes.LESS:
                return leftTerm &lt; rightTerm
            elif operator.type == TokenTypes.LESS_EQUALS:
                return leftTerm &lt;= rightTerm
            elif operator.type == TokenTypes.EQUALS:
                return leftTerm == rightTerm
            elif operator.type == TokenTypes.DIFFERENT:
                return leftTerm != rightTerm

            elif operator.type == TokenTypes.AND:
                return leftTerm and rightTerm
            elif operator.type == TokenTypes.OR:
                return leftTerm or rightTerm


    @staticmethod
    def evaluateStatement(statement: Statement):
        stmtIdx = 0

        while stmtIdx &lt; len(statement.getChildren()):
            stmt = statement.getChildren()[stmtIdx]

            numberOfConditionalStmt = SyntaxEvaluator.appendConditionalSyntax(stmt, statement, stmtIdx)

            if numberOfConditionalStmt &gt; 0:
                stmtIdx += numberOfConditionalStmt
                continue

            elif isinstance(stmt, WhileStatement):
                SyntaxEvaluator.evaluateWhileStatement(stmt)

            elif isinstance(stmt, VarDeclareSyntax):
                SyntaxEvaluator.evaluateVarDeclareStatement(stmt)

            elif isinstance(stmt, VarAssignSyntax):
                SyntaxEvaluator.evaluateVarAssignStatement(stmt)

            elif isinstance(stmt, PrintStatement):
                SyntaxEvaluator.evaluatePrintStatement(stmt)

            stmtIdx += 1

    @staticmethod
    def evaluatePrintStatement(printStatement):
        valueToPrint = SyntaxEvaluator.evaluateExpression(printStatement.valueToPrint)
        print(valueToPrint)

    @staticmethod
    def evaluateVarAssignStatement(assignStmt: VarAssignSyntax):
        varType = assignStmt.varType
        varName = assignStmt.identifier.value
        varValue = SyntaxEvaluator.evaluateVarValue(assignStmt.value)
        availableTypes = {
            &#34;number&#34;: [float, int],
            &#34;str&#34;: [str],
            &#34;bool&#34;: [bool]
        }

        if varType:
            varType = varType.value
            assignType = None

            for typeKey, v in availableTypes.items():
                for typeValue in v:
                    if type(varValue) == typeValue:
                        assignType = typeKey
                        break

            if assignType != varType:
                raise Exception(f&#34;Type {varType} cannot be assigned to {assignType}&#34;)

            varSymbol = Symbol(varType, varName, varValue)
            core.SymbolsTable.storeSymbol(varSymbol)
        else:
            symbolType = core.SymbolsTable.findSymbolByKey(varName).type
            assignType = None

            for typeKey, v in availableTypes.items():
                for typeValue in v:
                    if type(varValue) == typeValue:
                        assignType = typeKey
                        break

            if assignType != symbolType:
                raise Exception(f&#34;Type {symbolType} cannot be assigned to {assignType}&#34;)

            core.SymbolsTable.updateSymbol(varName, varValue)

    @staticmethod
    def evaluateVarDeclareStatement(declareStmt: VarDeclareSyntax):
        varType = declareStmt.varType.value
        varName = declareStmt.identifier.value

        varSymbol = Symbol(varType, varName, None)
        core.SymbolsTable.storeSymbol(varSymbol)

    @staticmethod
    def evaluateWhileStatement(whileStmt: WhileStatement):
        while SyntaxEvaluator.evaluateExpression(whileStmt.conditions):
            SyntaxEvaluator.evaluateStatement(whileStmt.scope)

    @staticmethod
    def evaluateConditionalStatement(conditionalNodes):
        ifStmt = conditionalNodes[0]

        if SyntaxEvaluator.evaluateExpression(ifStmt.conditions):
            SyntaxEvaluator.evaluateStatement(ifStmt.scope)
            return

        elif len(conditionalNodes) &gt; 1:
            nodeIdx = 1
            while isinstance(conditionalNodes[nodeIdx], ElifStatement):
                elifStmt = conditionalNodes[nodeIdx]

                if SyntaxEvaluator.evaluateExpression(elifStmt.conditions):
                    SyntaxEvaluator.evaluateStatement(elifStmt.scope)
                    return

                nodeIdx += 1

            if isinstance(conditionalNodes[nodeIdx], ElseStatement):
                elseStmt = conditionalNodes[nodeIdx]
                SyntaxEvaluator.evaluateStatement(elseStmt.scope)
                return

    @staticmethod
    def appendConditionalSyntax(node, statement, idx):
        conditionalsStatements = []

        if isinstance(node, IfStatement):
            conditionalsStatements.append(node)

            nextIdx = idx + 1
            if nextIdx &lt; len(statement.getChildren()):
                while isinstance(statement.getChildren()[nextIdx], ElifStatement):
                    conditionalsStatements.append(statement.getChildren()[nextIdx])
                    if len(statement.getChildren()) &gt; nextIdx + 1:
                        nextIdx += 1
                    else:
                        break

                if isinstance(statement.getChildren()[nextIdx], ElseStatement):
                    conditionalsStatements.append(statement.getChildren()[nextIdx])

            SyntaxEvaluator.evaluateConditionalStatement(conditionalsStatements)

        return len(conditionalsStatements)

    @staticmethod
    def evaluateVarValue(varValue):
        if isinstance(varValue, InputStatement):
            inputValue = input()
            try:
                return float(inputValue)
            except:
                return inputValue

        return SyntaxEvaluator.evaluateExpression(varValue)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator"><code class="flex name class">
<span>class <span class="ident">SyntaxEvaluator</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SyntaxEvaluator:

    @staticmethod
    def evaluateExpression(node: SyntaxNode):

        # IS LITERAL LEAF
        if isinstance(node, NumberExpression):
            return node.numberLiteralToken.value

        elif isinstance(node, BooleanExpression):
            return node.booleanLiteralToken.value

        elif isinstance(node, StringExpression):
            return node.stringLiteralToken.value

        # IS IDENTIFIER LEAF
        if isinstance(node, IdentifierExpression):
            varSymbol = core.SymbolsTable.findSymbolByKey(node.identifierToken.value)
            return varSymbol.value

        elif isinstance(node, ParenthesizedExpression):
            return SyntaxEvaluator.evaluateExpression(node.expression)

        elif isinstance(node, BinaryExpression):
            leftTerm = SyntaxEvaluator.evaluateExpression(node.leftTerm)
            rightTerm = SyntaxEvaluator.evaluateExpression(node.rightTerm)
            operator: Token = node.operator

            if operator.type == TokenTypes.PLUS:
                return leftTerm + rightTerm
            elif operator.type == TokenTypes.MINUS:
                return leftTerm - rightTerm
            elif operator.type == TokenTypes.DIVISION:
                return leftTerm / rightTerm
            elif operator.type == TokenTypes.MULTIPLY:
                return leftTerm * rightTerm

            elif operator.type == TokenTypes.GREATER:
                return leftTerm &gt; rightTerm
            elif operator.type == TokenTypes.GREATER_EQUALS:
                return leftTerm &gt;= rightTerm
            elif operator.type == TokenTypes.LESS:
                return leftTerm &lt; rightTerm
            elif operator.type == TokenTypes.LESS_EQUALS:
                return leftTerm &lt;= rightTerm
            elif operator.type == TokenTypes.EQUALS:
                return leftTerm == rightTerm
            elif operator.type == TokenTypes.DIFFERENT:
                return leftTerm != rightTerm

            elif operator.type == TokenTypes.AND:
                return leftTerm and rightTerm
            elif operator.type == TokenTypes.OR:
                return leftTerm or rightTerm


    @staticmethod
    def evaluateStatement(statement: Statement):
        stmtIdx = 0

        while stmtIdx &lt; len(statement.getChildren()):
            stmt = statement.getChildren()[stmtIdx]

            numberOfConditionalStmt = SyntaxEvaluator.appendConditionalSyntax(stmt, statement, stmtIdx)

            if numberOfConditionalStmt &gt; 0:
                stmtIdx += numberOfConditionalStmt
                continue

            elif isinstance(stmt, WhileStatement):
                SyntaxEvaluator.evaluateWhileStatement(stmt)

            elif isinstance(stmt, VarDeclareSyntax):
                SyntaxEvaluator.evaluateVarDeclareStatement(stmt)

            elif isinstance(stmt, VarAssignSyntax):
                SyntaxEvaluator.evaluateVarAssignStatement(stmt)

            elif isinstance(stmt, PrintStatement):
                SyntaxEvaluator.evaluatePrintStatement(stmt)

            stmtIdx += 1

    @staticmethod
    def evaluatePrintStatement(printStatement):
        valueToPrint = SyntaxEvaluator.evaluateExpression(printStatement.valueToPrint)
        print(valueToPrint)

    @staticmethod
    def evaluateVarAssignStatement(assignStmt: VarAssignSyntax):
        varType = assignStmt.varType
        varName = assignStmt.identifier.value
        varValue = SyntaxEvaluator.evaluateVarValue(assignStmt.value)
        availableTypes = {
            &#34;number&#34;: [float, int],
            &#34;str&#34;: [str],
            &#34;bool&#34;: [bool]
        }

        if varType:
            varType = varType.value
            assignType = None

            for typeKey, v in availableTypes.items():
                for typeValue in v:
                    if type(varValue) == typeValue:
                        assignType = typeKey
                        break

            if assignType != varType:
                raise Exception(f&#34;Type {varType} cannot be assigned to {assignType}&#34;)

            varSymbol = Symbol(varType, varName, varValue)
            core.SymbolsTable.storeSymbol(varSymbol)
        else:
            symbolType = core.SymbolsTable.findSymbolByKey(varName).type
            assignType = None

            for typeKey, v in availableTypes.items():
                for typeValue in v:
                    if type(varValue) == typeValue:
                        assignType = typeKey
                        break

            if assignType != symbolType:
                raise Exception(f&#34;Type {symbolType} cannot be assigned to {assignType}&#34;)

            core.SymbolsTable.updateSymbol(varName, varValue)

    @staticmethod
    def evaluateVarDeclareStatement(declareStmt: VarDeclareSyntax):
        varType = declareStmt.varType.value
        varName = declareStmt.identifier.value

        varSymbol = Symbol(varType, varName, None)
        core.SymbolsTable.storeSymbol(varSymbol)

    @staticmethod
    def evaluateWhileStatement(whileStmt: WhileStatement):
        while SyntaxEvaluator.evaluateExpression(whileStmt.conditions):
            SyntaxEvaluator.evaluateStatement(whileStmt.scope)

    @staticmethod
    def evaluateConditionalStatement(conditionalNodes):
        ifStmt = conditionalNodes[0]

        if SyntaxEvaluator.evaluateExpression(ifStmt.conditions):
            SyntaxEvaluator.evaluateStatement(ifStmt.scope)
            return

        elif len(conditionalNodes) &gt; 1:
            nodeIdx = 1
            while isinstance(conditionalNodes[nodeIdx], ElifStatement):
                elifStmt = conditionalNodes[nodeIdx]

                if SyntaxEvaluator.evaluateExpression(elifStmt.conditions):
                    SyntaxEvaluator.evaluateStatement(elifStmt.scope)
                    return

                nodeIdx += 1

            if isinstance(conditionalNodes[nodeIdx], ElseStatement):
                elseStmt = conditionalNodes[nodeIdx]
                SyntaxEvaluator.evaluateStatement(elseStmt.scope)
                return

    @staticmethod
    def appendConditionalSyntax(node, statement, idx):
        conditionalsStatements = []

        if isinstance(node, IfStatement):
            conditionalsStatements.append(node)

            nextIdx = idx + 1
            if nextIdx &lt; len(statement.getChildren()):
                while isinstance(statement.getChildren()[nextIdx], ElifStatement):
                    conditionalsStatements.append(statement.getChildren()[nextIdx])
                    if len(statement.getChildren()) &gt; nextIdx + 1:
                        nextIdx += 1
                    else:
                        break

                if isinstance(statement.getChildren()[nextIdx], ElseStatement):
                    conditionalsStatements.append(statement.getChildren()[nextIdx])

            SyntaxEvaluator.evaluateConditionalStatement(conditionalsStatements)

        return len(conditionalsStatements)

    @staticmethod
    def evaluateVarValue(varValue):
        if isinstance(varValue, InputStatement):
            inputValue = input()
            try:
                return float(inputValue)
            except:
                return inputValue

        return SyntaxEvaluator.evaluateExpression(varValue)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.appendConditionalSyntax"><code class="name flex">
<span>def <span class="ident">appendConditionalSyntax</span></span>(<span>node, statement, idx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def appendConditionalSyntax(node, statement, idx):
    conditionalsStatements = []

    if isinstance(node, IfStatement):
        conditionalsStatements.append(node)

        nextIdx = idx + 1
        if nextIdx &lt; len(statement.getChildren()):
            while isinstance(statement.getChildren()[nextIdx], ElifStatement):
                conditionalsStatements.append(statement.getChildren()[nextIdx])
                if len(statement.getChildren()) &gt; nextIdx + 1:
                    nextIdx += 1
                else:
                    break

            if isinstance(statement.getChildren()[nextIdx], ElseStatement):
                conditionalsStatements.append(statement.getChildren()[nextIdx])

        SyntaxEvaluator.evaluateConditionalStatement(conditionalsStatements)

    return len(conditionalsStatements)</code></pre>
</details>
</dd>
<dt id="cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.evaluateConditionalStatement"><code class="name flex">
<span>def <span class="ident">evaluateConditionalStatement</span></span>(<span>conditionalNodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def evaluateConditionalStatement(conditionalNodes):
    ifStmt = conditionalNodes[0]

    if SyntaxEvaluator.evaluateExpression(ifStmt.conditions):
        SyntaxEvaluator.evaluateStatement(ifStmt.scope)
        return

    elif len(conditionalNodes) &gt; 1:
        nodeIdx = 1
        while isinstance(conditionalNodes[nodeIdx], ElifStatement):
            elifStmt = conditionalNodes[nodeIdx]

            if SyntaxEvaluator.evaluateExpression(elifStmt.conditions):
                SyntaxEvaluator.evaluateStatement(elifStmt.scope)
                return

            nodeIdx += 1

        if isinstance(conditionalNodes[nodeIdx], ElseStatement):
            elseStmt = conditionalNodes[nodeIdx]
            SyntaxEvaluator.evaluateStatement(elseStmt.scope)
            return</code></pre>
</details>
</dd>
<dt id="cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.evaluateExpression"><code class="name flex">
<span>def <span class="ident">evaluateExpression</span></span>(<span>node: Parser.SyntaxNode.SyntaxNode.SyntaxNode)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def evaluateExpression(node: SyntaxNode):

    # IS LITERAL LEAF
    if isinstance(node, NumberExpression):
        return node.numberLiteralToken.value

    elif isinstance(node, BooleanExpression):
        return node.booleanLiteralToken.value

    elif isinstance(node, StringExpression):
        return node.stringLiteralToken.value

    # IS IDENTIFIER LEAF
    if isinstance(node, IdentifierExpression):
        varSymbol = core.SymbolsTable.findSymbolByKey(node.identifierToken.value)
        return varSymbol.value

    elif isinstance(node, ParenthesizedExpression):
        return SyntaxEvaluator.evaluateExpression(node.expression)

    elif isinstance(node, BinaryExpression):
        leftTerm = SyntaxEvaluator.evaluateExpression(node.leftTerm)
        rightTerm = SyntaxEvaluator.evaluateExpression(node.rightTerm)
        operator: Token = node.operator

        if operator.type == TokenTypes.PLUS:
            return leftTerm + rightTerm
        elif operator.type == TokenTypes.MINUS:
            return leftTerm - rightTerm
        elif operator.type == TokenTypes.DIVISION:
            return leftTerm / rightTerm
        elif operator.type == TokenTypes.MULTIPLY:
            return leftTerm * rightTerm

        elif operator.type == TokenTypes.GREATER:
            return leftTerm &gt; rightTerm
        elif operator.type == TokenTypes.GREATER_EQUALS:
            return leftTerm &gt;= rightTerm
        elif operator.type == TokenTypes.LESS:
            return leftTerm &lt; rightTerm
        elif operator.type == TokenTypes.LESS_EQUALS:
            return leftTerm &lt;= rightTerm
        elif operator.type == TokenTypes.EQUALS:
            return leftTerm == rightTerm
        elif operator.type == TokenTypes.DIFFERENT:
            return leftTerm != rightTerm

        elif operator.type == TokenTypes.AND:
            return leftTerm and rightTerm
        elif operator.type == TokenTypes.OR:
            return leftTerm or rightTerm</code></pre>
</details>
</dd>
<dt id="cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.evaluatePrintStatement"><code class="name flex">
<span>def <span class="ident">evaluatePrintStatement</span></span>(<span>printStatement)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def evaluatePrintStatement(printStatement):
    valueToPrint = SyntaxEvaluator.evaluateExpression(printStatement.valueToPrint)
    print(valueToPrint)</code></pre>
</details>
</dd>
<dt id="cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.evaluateStatement"><code class="name flex">
<span>def <span class="ident">evaluateStatement</span></span>(<span>statement: Parser.SyntaxTypes.Statement.Statement.Statement)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def evaluateStatement(statement: Statement):
    stmtIdx = 0

    while stmtIdx &lt; len(statement.getChildren()):
        stmt = statement.getChildren()[stmtIdx]

        numberOfConditionalStmt = SyntaxEvaluator.appendConditionalSyntax(stmt, statement, stmtIdx)

        if numberOfConditionalStmt &gt; 0:
            stmtIdx += numberOfConditionalStmt
            continue

        elif isinstance(stmt, WhileStatement):
            SyntaxEvaluator.evaluateWhileStatement(stmt)

        elif isinstance(stmt, VarDeclareSyntax):
            SyntaxEvaluator.evaluateVarDeclareStatement(stmt)

        elif isinstance(stmt, VarAssignSyntax):
            SyntaxEvaluator.evaluateVarAssignStatement(stmt)

        elif isinstance(stmt, PrintStatement):
            SyntaxEvaluator.evaluatePrintStatement(stmt)

        stmtIdx += 1</code></pre>
</details>
</dd>
<dt id="cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.evaluateVarAssignStatement"><code class="name flex">
<span>def <span class="ident">evaluateVarAssignStatement</span></span>(<span>assignStmt: Parser.SyntaxTypes.Statement.SimpleStatement.VarAssignSyntax.VarAssignSyntax)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def evaluateVarAssignStatement(assignStmt: VarAssignSyntax):
    varType = assignStmt.varType
    varName = assignStmt.identifier.value
    varValue = SyntaxEvaluator.evaluateVarValue(assignStmt.value)
    availableTypes = {
        &#34;number&#34;: [float, int],
        &#34;str&#34;: [str],
        &#34;bool&#34;: [bool]
    }

    if varType:
        varType = varType.value
        assignType = None

        for typeKey, v in availableTypes.items():
            for typeValue in v:
                if type(varValue) == typeValue:
                    assignType = typeKey
                    break

        if assignType != varType:
            raise Exception(f&#34;Type {varType} cannot be assigned to {assignType}&#34;)

        varSymbol = Symbol(varType, varName, varValue)
        core.SymbolsTable.storeSymbol(varSymbol)
    else:
        symbolType = core.SymbolsTable.findSymbolByKey(varName).type
        assignType = None

        for typeKey, v in availableTypes.items():
            for typeValue in v:
                if type(varValue) == typeValue:
                    assignType = typeKey
                    break

        if assignType != symbolType:
            raise Exception(f&#34;Type {symbolType} cannot be assigned to {assignType}&#34;)

        core.SymbolsTable.updateSymbol(varName, varValue)</code></pre>
</details>
</dd>
<dt id="cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.evaluateVarDeclareStatement"><code class="name flex">
<span>def <span class="ident">evaluateVarDeclareStatement</span></span>(<span>declareStmt: Parser.SyntaxTypes.Statement.SimpleStatement.VarDeclareSyntax.VarDeclareSyntax)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def evaluateVarDeclareStatement(declareStmt: VarDeclareSyntax):
    varType = declareStmt.varType.value
    varName = declareStmt.identifier.value

    varSymbol = Symbol(varType, varName, None)
    core.SymbolsTable.storeSymbol(varSymbol)</code></pre>
</details>
</dd>
<dt id="cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.evaluateVarValue"><code class="name flex">
<span>def <span class="ident">evaluateVarValue</span></span>(<span>varValue)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def evaluateVarValue(varValue):
    if isinstance(varValue, InputStatement):
        inputValue = input()
        try:
            return float(inputValue)
        except:
            return inputValue

    return SyntaxEvaluator.evaluateExpression(varValue)</code></pre>
</details>
</dd>
<dt id="cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.evaluateWhileStatement"><code class="name flex">
<span>def <span class="ident">evaluateWhileStatement</span></span>(<span>whileStmt: Parser.SyntaxTypes.Statement.SelectionStatement.WhileStatement.WhileStatement)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def evaluateWhileStatement(whileStmt: WhileStatement):
    while SyntaxEvaluator.evaluateExpression(whileStmt.conditions):
        SyntaxEvaluator.evaluateStatement(whileStmt.scope)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cython-1.Parser.SyntaxEvaluator" href="index.html">cython-1.Parser.SyntaxEvaluator</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator" href="#cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator">SyntaxEvaluator</a></code></h4>
<ul class="">
<li><code><a title="cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.appendConditionalSyntax" href="#cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.appendConditionalSyntax">appendConditionalSyntax</a></code></li>
<li><code><a title="cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.evaluateConditionalStatement" href="#cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.evaluateConditionalStatement">evaluateConditionalStatement</a></code></li>
<li><code><a title="cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.evaluateExpression" href="#cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.evaluateExpression">evaluateExpression</a></code></li>
<li><code><a title="cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.evaluatePrintStatement" href="#cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.evaluatePrintStatement">evaluatePrintStatement</a></code></li>
<li><code><a title="cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.evaluateStatement" href="#cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.evaluateStatement">evaluateStatement</a></code></li>
<li><code><a title="cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.evaluateVarAssignStatement" href="#cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.evaluateVarAssignStatement">evaluateVarAssignStatement</a></code></li>
<li><code><a title="cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.evaluateVarDeclareStatement" href="#cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.evaluateVarDeclareStatement">evaluateVarDeclareStatement</a></code></li>
<li><code><a title="cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.evaluateVarValue" href="#cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.evaluateVarValue">evaluateVarValue</a></code></li>
<li><code><a title="cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.evaluateWhileStatement" href="#cython-1.Parser.SyntaxEvaluator.SyntaxEvaluator.SyntaxEvaluator.evaluateWhileStatement">evaluateWhileStatement</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>